package edu.webdev.catalog.controllers;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import edu.webdev.catalog.catalogue.ProductCommandService; // Import the command service
import edu.webdev.catalog.catalogue.ProductQueryService; // Import the query service
import edu.webdev.catalog.catalogue.applications.commands.CreateProductCommand; // Import commands
import edu.webdev.catalog.catalogue.applications.commands.DeleteProductCommand;
import edu.webdev.catalog.catalogue.applications.commands.UpdateProductCommand;
import edu.webdev.catalog.catalogue.applications.queries.RetrieveProductQuery; // Import queries
import edu.webdev.catalog.catalogue.applications.queries.SearchProductQuery;

// Import domain types for mapping (assuming factory methods handle conversion from DTO types)
import edu.webdev.catalog.catalogue.domain.Category;
import edu.webdev.catalog.catalogue.domain.Description;
import edu.webdev.catalog.catalogue.domain.Model;
import edu.webdev.catalog.catalogue.domain.ProductId;
import edu.webdev.catalog.catalogue.domain.ProductName;
import edu.webdev.catalog.catalogue.domain.StockQuantity;
import edu.webdev.catalog.shared.utils.Money; // Assuming Money can be created from BigDecimal and String currency
import edu.webdev.catalog.catalogue.applications.queries.SearchProductQuery.PriceOperator; // If using price filtering in SearchProductQuery

// Import persistence projections for mapping results
import edu.webdev.catalog.infrastructure.persistence.repositories.projections.ProductDetail;
import edu.webdev.catalog.infrastructure.persistence.repositories.projections.ProductSummary;

// Import DTOs
import edu.webdev.catalog.dto.CreateProductRequest;
import edu.webdev.catalog.dto.UpdateProductRequest;
import edu.webdev.catalog.dto.SearchProductsRequest;
import edu.webdev.catalog.dto.ProductDetailResponse;
import edu.webdev.catalog.dto.ProductSummaryResponse;

import java.util.Map; // For simple responses
import java.util.Currency; // Import Currency

// Import Lombok's RequiredArgsConstructor
import lombok.RequiredArgsConstructor;

/**
 * Controller for managing product catalog items.
 * Injects ProductCommandService and ProductQueryService to handle product operations.
 * Uses DTOs for request and response bodies, consistent with persistence layer ID type (Long).
 * Relies on global exception handling for errors.
 */
@RestController
@RequestMapping("/products") // Base URL for product endpoints
@RequiredArgsConstructor // Lombok annotation for constructor injection
public class ProductController {

    // Injected services for command and query operations
    private final ProductCommandService productCommandService;
    private final ProductQueryService productQueryService;

    // The constructor is generated by Lombok's @RequiredArgsConstructor

    /**
     * Handles creating a new product.
     * Maps to POST /products.
     *
     * @param request The request body containing product details.
     * @return ResponseEntity indicating success (201 Created) or error.
     * Exceptions (e.g., validation, data conflicts) are handled globally.
     */
    @PostMapping
    public ResponseEntity<Map<String, String>> createProduct(@RequestBody /* @Valid */ CreateProductRequest request) {

        // Map the request DTO to the domain command object
        // Assuming domain types (ProductName, Model, etc.) have static factory methods from primitive types
        CreateProductCommand command = new CreateProductCommand(
            ProductName.create(request.getName()),
            Model.create(request.getModel()),
            Description.create(request.getDescription()),
            Money.create(request.getPrice(), Currency.getInstance(request.getCurrency())),
            StockQuantity.create(request.getStockQuantity()),
            Category.create(request.getCategory()) // Assuming Category.create takes String
        );

        productCommandService.addNewProduct(command);

        // Return a 201 Created status with a success message
        return ResponseEntity.status(HttpStatus.CREATED).body(Map.of("message", "Product created successfully"));
    }

    /**
     * Handles updating an existing product.
     * Maps to PUT /products/{id}.
     *
     * @param id The ID of the product to update (from path variable). Use Long.
     * @param request The request body containing updated product details.
     * @return ResponseEntity indicating success (200 OK) or error.
     * Exceptions (e.g., not found, validation) are handled globally.
     */
    @PutMapping("/{id}")
    public ResponseEntity<Map<String, String>> updateProduct(@PathVariable Long id, @RequestBody /* @Valid */ UpdateProductRequest request) {

        // Map the request DTO and path variable ID to the domain command object
        // Handle potential IllegalArgumentException from domain factory methods
        UpdateProductCommand command = new UpdateProductCommand(
             ProductId.of(id), // Using the correct factory method
             request.getName() != null ? ProductName.create(request.getName()) : null,
             request.getModel() != null ? Model.create(request.getModel()) : null,
             request.getDescription() != null ? Description.create(request.getDescription()) : null,
             // If price is provided, create Money. If currency is also provided, use it. Otherwise, assume a default.
             // Handle potential IllegalArgumentException from Currency.getInstance() or Money.create().
             request.getPrice() != null
                 ? (request.getCurrency() != null
                     ? Money.create(request.getPrice(), Currency.getInstance(request.getCurrency())) // Use provided currency
                     : Money.create(request.getPrice(), Currency.getInstance("USD"))) // Use default currency if only price is provided
                 : null, // If price is not provided, Money is null
             request.getStockQuantity() != null ? StockQuantity.create(request.getStockQuantity()) : null,
             request.getCategory() != null ? Category.create(request.getCategory()) : null
        );

        productCommandService.modifyProduct(command);

        // Return a 200 OK status with a success message
        return ResponseEntity.ok(Map.of("message", "Product updated successfully"));
    }

    /**
     * Handles deleting a product by its ID.
     * Maps to DELETE /products/{id}.
     *
     * @param id The ID of the product to delete (from path variable). Use Long.
     * @return ResponseEntity indicating success (200 OK) or error.
     * Exceptions (e.g., not found) are handled globally.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Map<String, String>> deleteProduct(@PathVariable Long id) {
        // Map the path variable ID to the domain command object
        DeleteProductCommand command = new DeleteProductCommand(
            ProductId.of(id)
        );

        productCommandService.deleteProduct(command);

        // Return a 200 OK status with a success message
        return ResponseEntity.ok(Map.of("message", "Product deleted successfully"));
    }

    /**
     * Handles retrieving a product by its ID.
     * Maps to GET /products/{id}.
     *
     * @param id The ID of the product to retrieve (from path variable). Use Long.
     * @return ResponseEntity containing the product details (200 OK) or error.
     * Exceptions (e.g., not found) are handled globally.
     */
    @GetMapping("/{id}")
    public ResponseEntity<ProductDetailResponse> getProductById(@PathVariable Long id) {
        // Map the path variable ID to the domain query object
        RetrieveProductQuery query = new RetrieveProductQuery(
            ProductId.of(id)
        );

        // Call the query service to find the product
        ProductDetail productDetail = productQueryService.findProductById(query);

        // Map the backend projection to the response DTO

        ProductDetailResponse response = new ProductDetailResponse(
             productDetail.getId(),
             productDetail.getName(),
             productDetail.getModel(),
             productDetail.getDescription(),
             productDetail.getAmount(),
             productDetail.getCurrency(),
             productDetail.getStockQuantity(),
             productDetail.getCategory()
        );

        return ResponseEntity.ok(response);
    }

    /**
     * Handles searching for products with pagination and filtering.
     * Maps to GET /products/search.
     * Query parameters are automatically mapped to SearchProductsRequest DTO.
     *
     * @param request The request object containing search criteria and pagination.
     * @return ResponseEntity containing a page of product summaries (200 OK) or error.
     * Exceptions are handled globally.
     */
    @GetMapping("/search")
    public ResponseEntity<Page<ProductSummaryResponse>> searchProducts(SearchProductsRequest request) {
        // Spring automatically maps query parameters to the SearchProductsRequest DTO.

        // Map priceOperator from DTO, converting String to PriceOperator enum if not null
        PriceOperator operator = null;
        if (request.getPriceOperator() != null) {
            try {
                operator = PriceOperator.valueOf(request.getPriceOperator());
            } catch (IllegalArgumentException e) {
                // Handle invalid operator string - return a BAD_REQUEST response
                // Log the error if needed
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Page.empty()); // Return empty page with error status
            }
        }

        // Combine name, model, and category from the request into a single keyword for the query
        String keyword = null;
        if (request.getName() != null || request.getModel() != null || request.getCategory() != null) {
             // Simple concatenation 
             StringBuilder keywordBuilder = new StringBuilder();
             if (request.getName() != null) keywordBuilder.append(request.getName()).append(" ");
             if (request.getModel() != null) keywordBuilder.append(request.getModel()).append(" ");
             if (request.getCategory() != null) keywordBuilder.append(request.getCategory());
             keyword = keywordBuilder.toString().trim();
        }


        // Use SearchProductQuery.builder() to construct the query object
        SearchProductQuery query = SearchProductQuery.builder()
             .keyword(keyword) // Map the combined keyword
             .price(request.getPrice())
             .priceOperator(operator) // Pass the mapped PriceOperator enum (can be null)
             .page(request.getPage())
             .size(request.getSize()) 
             // Map sort field and direction from DTO, converting String direction to Sort.Direction enum
             .sortBy(request.getSortBy())
             .sortDirection(Sort.Direction.fromString(request.getSortDirection()))
             .build();

        // Call the query service to search for products
        Page<ProductSummary> productSummaryPage = productQueryService.searchPageOfProduct(query);

        // Map the Page of backend projections to a Page of response DTOs
        Page<ProductSummaryResponse> responsePage = productSummaryPage.map(summary -> new ProductSummaryResponse(
             summary.id(),
             summary.name(),
             summary.model(),
             summary.amount(),
             summary.currency(),
             summary.stockQuantity(),
             summary.category()
        ));


        // Return the page of product summaries with a 200 OK status
        return ResponseEntity.ok(responsePage);
    }
}
